#![allow(dead_code)]
#![allow(unsafe_op_in_unsafe_fn)]
/* automatically generated by rust-bindgen 0.71.1 */

pub const _ELIX_LEVEL: u32 = 4;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.3.0\0";
pub const _PICOLIBC_CTYPE_SMALL: u32 = 0;
pub const _PICOLIBC_MINOR__: u32 = 8;
pub const _PICOLIBC_VERSION: &[u8; 6] = b"1.8.6\0";
pub const _PICOLIBC__: u32 = 1;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const __NEWLIB__: u32 = 4;
pub const __PICOLIBC_MINOR__: u32 = 8;
pub const __PICOLIBC_PATCHLEVEL__: u32 = 6;
pub const __PICOLIBC_VERSION__: &[u8; 6] = b"1.8.6\0";
pub const __PICOLIBC__: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 1;
pub const __ZEPHYR_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2020;
pub const __LARGEFILE_VISIBLE: u32 = 1;
pub const __LARGEFILE64_VISIBLE: u32 = 1;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 700;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __OBSOLETE_MATH_FLOAT: u32 = 1;
pub const __OBSOLETE_MATH_DOUBLE: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const TICK_TYPE_WIDTH_16_BITS: u32 = 0;
pub const TICK_TYPE_WIDTH_32_BITS: u32 = 1;
pub const TICK_TYPE_WIDTH_64_BITS: u32 = 2;
pub const configPRIO_BITS: u32 = 4;
pub const configLIBRARY_LOWEST_INTERRUPT_PRIORITY: u32 = 15;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 240;
pub const configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 5;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 80;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 0;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 0;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configMAX_PRIORITIES: u32 = 16;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configUSE_TRACE_FACILITY: u32 = 1;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 1;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const configTASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 5;
pub const configTIMER_TASK_PRIORITY: u32 = 1;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 400;
pub const configTIMER_QUEUE_LENGTH: u32 = 5;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 0;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const INCLUDE_vTaskPrioritySet: u32 = 0;
pub const INCLUDE_uxTaskPriorityGet: u32 = 0;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const configUSE_TIME_SLICING: u32 = 0;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configTICK_TYPE_WIDTH_IN_BITS: u32 = 1;
pub const configUSE_MPU_WRAPPERS_V1: u32 = 0;
pub const configENABLE_ACCESS_CONTROL_LIST: u32 = 0;
pub const configNUMBER_OF_CORES: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_EAFNOSUPPORT: u32 = 97;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 1;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 8;
pub const portNVIC_PENDSVSET_BIT: u32 = 268435456;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 1;
pub const portBYTE_ALIGNMENT_MASK: u32 = 7;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portHAS_STACK_OVERFLOW_CHECKING: u32 = 0;
pub const configSTACK_ALLOCATION_FROM_SEPARATE_HEAP: u32 = 0;
pub const configUSE_NEWLIB_REENTRANT: u32 = 0;
pub const configUSE_PICOLIBC_TLS: u32 = 0;
pub const configUSE_C_RUNTIME_TLS_SUPPORT: u32 = 0;
pub const INCLUDE_xTaskDelayUntil: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 0;
pub const INCLUDE_xTaskAbortDelay: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 0;
pub const INCLUDE_xTaskGetHandle: u32 = 0;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 0;
pub const INCLUDE_uxTaskGetStackHighWaterMark2: u32 = 0;
pub const INCLUDE_eTaskGetState: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 0;
pub const configUSE_TASK_PREEMPTION_DISABLE: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const configASSERT_DEFINED: u32 = 1;
pub const configPRECONDITION_DEFINED: u32 = 0;
pub const configCHECK_HANDLER_INSTALLATION: u32 = 1;
pub const configRUN_MULTIPLE_PRIORITIES: u32 = 0;
pub const configUSE_CORE_AFFINITY: u32 = 0;
pub const configUSE_PASSIVE_IDLE_HOOK: u32 = 0;
pub const configUSE_MINI_LIST_ITEM: u32 = 1;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_TICKLESS_IDLE: u32 = 0;
pub const configUSE_QUEUE_SETS: u32 = 0;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configENABLE_HEAP_PROTECTOR: u32 = 0;
pub const configUSE_POSIX_ERRNO: u32 = 0;
pub const configUSE_SB_COMPLETED_CALLBACK: u32 = 0;
pub const configKERNEL_PROVIDED_STATIC_MEMORY: u32 = 0;
pub const configSTATS_BUFFER_MAX_LENGTH: u32 = 65535;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const configENABLE_MPU: u32 = 0;
pub const configENABLE_FPU: u32 = 1;
pub const configENABLE_MVE: u32 = 0;
pub const configENABLE_TRUSTZONE: u32 = 1;
pub const configRUN_FREERTOS_SECURE_ONLY: u32 = 0;
pub const configRUN_ADDITIONAL_TESTS: u32 = 0;
pub const tskKERNEL_VERSION_NUMBER: &[u8; 8] = b"V11.0.1\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 11;
pub const tskKERNEL_VERSION_MINOR: u32 = 0;
pub const tskKERNEL_VERSION_BUILD: u32 = 1;
pub const tskMPU_REGION_READ_ONLY: u32 = 1;
pub const tskMPU_REGION_READ_WRITE: u32 = 2;
pub const tskMPU_REGION_EXECUTE_NEVER: u32 = 4;
pub const tskMPU_REGION_NORMAL_MEMORY: u32 = 8;
pub const tskMPU_REGION_DEVICE_MEMORY: u32 = 16;
pub const tskMPU_READ_PERMISSION: u32 = 1;
pub const tskMPU_WRITE_PERMISSION: u32 = 2;
pub const tskDEFAULT_INDEX_TO_NOTIFY: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
unsafe extern "C" {
    pub static mut SystemCoreClock: cty::c_uint;
}
unsafe extern "C" {
    pub fn do_assert(a: *const cty::c_char);
}
pub type TaskFunction_t = ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void)>;
pub type StackType_t = cty::c_uint;
pub type BaseType_t = cty::c_long;
pub type UBaseType_t = cty::c_ulong;
pub type TickType_t = cty::c_uint;
unsafe extern "C" {
    pub fn vPortEnterCritical();
}
unsafe extern "C" {
    pub fn vPortExitCritical();
}
unsafe extern "C" {
    pub fn vPortSuppressTicksAndSleep(xExpectedIdleTime: TickType_t);
}
unsafe extern "C" {
    pub fn vPortValidateInterruptPriority();
}
unsafe extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut cty::c_void,
    ) -> *mut StackType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapRegion {
    pub pucStartAddress: *mut u8,
    pub xSizeInBytes: usize,
}
pub type HeapRegion_t = HeapRegion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xHeapStats {
    pub xAvailableHeapSpaceInBytes: usize,
    pub xSizeOfLargestFreeBlockInBytes: usize,
    pub xSizeOfSmallestFreeBlockInBytes: usize,
    pub xNumberOfFreeBlocks: usize,
    pub xMinimumEverFreeBytesRemaining: usize,
    pub xNumberOfSuccessfulAllocations: usize,
    pub xNumberOfSuccessfulFrees: usize,
}
pub type HeapStats_t = xHeapStats;
unsafe extern "C" {
    pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
unsafe extern "C" {
    pub fn vPortGetHeapStats(pxHeapStats: *mut HeapStats_t);
}
unsafe extern "C" {
    pub fn pvPortMalloc(xSize: usize) -> *mut cty::c_void;
}
unsafe extern "C" {
    pub fn pvPortCalloc(xNum: usize, xSize: usize) -> *mut cty::c_void;
}
unsafe extern "C" {
    pub fn vPortFree(pv: *mut cty::c_void);
}
unsafe extern "C" {
    pub fn vPortInitialiseBlocks();
}
unsafe extern "C" {
    pub fn xPortGetFreeHeapSize() -> usize;
}
unsafe extern "C" {
    pub fn xPortGetMinimumEverFreeHeapSize() -> usize;
}
unsafe extern "C" {
    pub fn vApplicationMallocFailedHook();
}
unsafe extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
unsafe extern "C" {
    pub fn vPortEndScheduler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut cty::c_void; 4usize],
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut cty::c_void; 2usize],
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy2: UBaseType_t,
    pub pvDummy3: *mut cty::c_void,
    pub xDummy4: StaticMiniListItem_t,
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut cty::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut cty::c_void,
    pub ucDummy7: [u8; 16usize],
    pub uxDummy10: [UBaseType_t; 2usize],
    pub uxDummy12: [UBaseType_t; 2usize],
    pub ulDummy18: [cty::c_uint; 5usize],
    pub ucDummy19: [u8; 5usize],
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut cty::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
    pub uxDummy8: UBaseType_t,
    pub ucDummy9: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut cty::c_void,
    pub uxDummy2: UBaseType_t,
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub uxDummy3: UBaseType_t,
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut cty::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub pvDummy5: *mut cty::c_void,
    pub pvDummy6: TaskFunction_t,
    pub uxDummy7: UBaseType_t,
    pub ucDummy8: u8,
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [usize; 4usize],
    pub pvDummy2: [*mut cty::c_void; 3usize],
    pub ucDummy3: u8,
    pub uxDummy4: UBaseType_t,
}
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut cty::c_void,
    pub pvContainer: *mut xLIST,
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
pub type List_t = xLIST;
unsafe extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
unsafe extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
pub type ConstTaskHandle_t = *const tskTaskControlBlock;
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut cty::c_void) -> BaseType_t>;
pub const eTaskState_eRunning: eTaskState = 0;
pub const eTaskState_eReady: eTaskState = 1;
pub const eTaskState_eBlocked: eTaskState = 2;
pub const eTaskState_eSuspended: eTaskState = 3;
pub const eTaskState_eDeleted: eTaskState = 4;
pub const eTaskState_eInvalid: eTaskState = 5;
pub type eTaskState = cty::c_uint;
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
pub type eNotifyAction = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut cty::c_void,
    pub ulLengthInBytes: cty::c_uint,
    pub ulParameters: cty::c_uint,
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const cty::c_char,
    pub usStackDepth: u16,
    pub pvParameters: *mut cty::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const cty::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: cty::c_uint,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: u16,
}
pub type TaskStatus_t = xTASK_STATUS;
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
pub type eSleepModeStatus = cty::c_uint;
unsafe extern "C" {
    pub fn xTaskCreate(
        pxTaskCode: TaskFunction_t,
        pcName: *const cty::c_char,
        usStackDepth: u16,
        pvParameters: *mut cty::c_void,
        uxPriority: UBaseType_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
unsafe extern "C" {
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
unsafe extern "C" {
    pub fn xTaskDelayUntil(
        pxPreviousWakeTime: *mut TickType_t,
        xTimeIncrement: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn uxTaskBasePriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn uxTaskBasePriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
unsafe extern "C" {
    pub fn vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
unsafe extern "C" {
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
unsafe extern "C" {
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
unsafe extern "C" {
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
unsafe extern "C" {
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskStartScheduler();
}
unsafe extern "C" {
    pub fn vTaskEndScheduler();
}
unsafe extern "C" {
    pub fn vTaskSuspendAll();
}
unsafe extern "C" {
    pub fn xTaskResumeAll() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskGetTickCount() -> TickType_t;
}
unsafe extern "C" {
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
unsafe extern "C" {
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
unsafe extern "C" {
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut cty::c_char;
}
unsafe extern "C" {
    pub fn vApplicationStackOverflowHook(xTask: TaskHandle_t, pcTaskName: *mut cty::c_char);
}
unsafe extern "C" {
    pub fn vApplicationTickHook();
}
unsafe extern "C" {
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut cty::c_uint,
    ) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: cty::c_uint,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut cty::c_uint,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: cty::c_uint,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut cty::c_uint,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskGenericNotifyWait(
        uxIndexToWaitOn: UBaseType_t,
        ulBitsToClearOnEntry: cty::c_uint,
        ulBitsToClearOnExit: cty::c_uint,
        pulNotificationValue: *mut cty::c_uint,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskGenericNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
unsafe extern "C" {
    pub fn ulTaskGenericNotifyTake(
        uxIndexToWaitOn: UBaseType_t,
        xClearCountOnExit: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> cty::c_uint;
}
unsafe extern "C" {
    pub fn xTaskGenericNotifyStateClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn ulTaskGenericNotifyValueClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
        ulBitsToClear: cty::c_uint,
    ) -> cty::c_uint;
}
unsafe extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
unsafe extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskCatchUpTicks(xTicksToCatchUp: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
unsafe extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
unsafe extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
unsafe extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
unsafe extern "C" {
    pub fn vTaskSwitchContext();
}
unsafe extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
unsafe extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn vTaskMissedYield();
}
unsafe extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
unsafe extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
unsafe extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tmrTimerControl {
    _unused: [u8; 0],
}
pub type TimerHandle_t = *mut tmrTimerControl;
pub type TimerCallbackFunction_t =
    ::core::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
pub type PendedFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: cty::c_uint)>;
unsafe extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const cty::c_char,
        xTimerPeriodInTicks: TickType_t,
        xAutoReload: BaseType_t,
        pvTimerID: *mut cty::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
unsafe extern "C" {
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut cty::c_void;
}
unsafe extern "C" {
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut cty::c_void);
}
unsafe extern "C" {
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn pcTimerGetName(xTimer: TimerHandle_t) -> *const cty::c_char;
}
unsafe extern "C" {
    pub fn vTimerSetReloadMode(xTimer: TimerHandle_t, xAutoReload: BaseType_t);
}
unsafe extern "C" {
    pub fn xTimerGetReloadMode(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGenericCommandFromTask(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGenericCommandFromISR(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTimerSetTimerNumber(xTimer: TimerHandle_t, uxTimerNumber: UBaseType_t);
}
unsafe extern "C" {
    pub fn uxTimerGetTimerNumber(xTimer: TimerHandle_t) -> UBaseType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventGroupDef_t {
    _unused: [u8; 0],
}
pub type EventGroupHandle_t = *mut EventGroupDef_t;
pub type EventBits_t = TickType_t;
unsafe extern "C" {
    pub fn xEventGroupCreate() -> EventGroupHandle_t;
}
unsafe extern "C" {
    pub fn xEventGroupWaitBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToWaitFor: EventBits_t,
        xClearOnExit: BaseType_t,
        xWaitForAllBits: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn xEventGroupClearBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn xEventGroupClearBitsFromISR(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xEventGroupSetBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn xEventGroupSetBitsFromISR(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xEventGroupSync(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        uxBitsToWaitFor: EventBits_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    pub fn xEventGroupGetBitsFromISR(xEventGroup: EventGroupHandle_t) -> EventBits_t;
}
unsafe extern "C" {
    pub fn vEventGroupDelete(xEventGroup: EventGroupHandle_t);
}
unsafe extern "C" {
    pub fn vEventGroupSetBitsCallback(pvEventGroup: *mut cty::c_void, ulBitsToSet: cty::c_uint);
}
unsafe extern "C" {
    pub fn vEventGroupClearBitsCallback(pvEventGroup: *mut cty::c_void, ulBitsToClear: cty::c_uint);
}
unsafe extern "C" {
    pub fn uxEventGroupGetNumber(xEventGroup: *mut cty::c_void) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vEventGroupSetNumber(xEventGroup: *mut cty::c_void, uxEventGroupNumber: UBaseType_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
pub type QueueSetHandle_t = *mut QueueDefinition;
pub type QueueSetMemberHandle_t = *mut QueueDefinition;
unsafe extern "C" {
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueuePeekFromISR(xQueue: QueueHandle_t, pvBuffer: *mut cty::c_void) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
unsafe extern "C" {
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueSemaphoreTake(xQueue: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
unsafe extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
unsafe extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
unsafe extern "C" {
    pub fn uxQueueGetQueueItemSize(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn uxQueueGetQueueLength(xQueue: QueueHandle_t) -> UBaseType_t;
}
pub type SemaphoreHandle_t = QueueHandle_t;
unsafe extern "C" {
    pub fn lnCreateTask(
        pxTaskCode: TaskFunction_t,
        pcName: *const cty::c_char,
        stackSizeInBytes: cty::c_int,
        pvParameters: *mut cty::c_void,
        uxPriority: UBaseType_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn Logger_chars(n: cty::c_int, data: *const cty::c_char);
}
